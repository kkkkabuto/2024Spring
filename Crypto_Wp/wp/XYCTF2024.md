# 1.Sign1n[签到]
- 题目：
```python
from Crypto.Util.number import *
from tqdm import *
import gmpy2
flag=b'XYCTF{uuid}'
flag=bytes_to_long(flag)
leak=bin(int(flag))
while 1:
    leak += "0"
    if len(leak) == 514:
        break

def swap_bits(input_str):
    input_list = list(input_str[2:])
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp

    return ''.join(input_list)

input_str = leak
result = swap_bits(input_str)
a=result

def custom_add(input_str):
    input_list = list(input_str)
    length = len(input_list)
    
    for i in range(length):
        input_list[i] = str((int(input_list[i]) + i + 1) % 10)

    result = ''.join(input_list)
    return result


input_str = a
result = custom_add(input_str)
b=result
print(b)
#12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567891134567799112455688902334677801133557889113356678911245577991223456790012455788902234677801124557799122355788001345578890123566789113445778012235578800123467889122356678911344567991223557880012455788912235667900124556899023355788001234578890123566780013445679902334577801134456899022346778902344578801233467789112355779912234577990233556780113
```
- 分析题目flag主要是被做了两次变换
- 第一次swap_bits()，交换了前后元素的位置，解密时可以直接用这个函数
- 第二次custom_add()，做了一些移位替换，解密只需要将str((int(input_list[i]) + i + 1) % 10)里面的加号换成减号
- 注意细节leak是二进制字符串，在swap_bits()交换元素是现去掉了"0b"，所以解密时需要添上"0b"再使用swap_bits()
- 解密过程：先将得到的数字以字符串形式表示，传入custom_add_decrypt()中进行移位变换，得到a，给a添上"0b"后使用swap_bits()交换元素位置，得到res:
```
10110000101100101000011010101000100011001111011001110000110001001100011011001000110010000110010001100000011000000101101011001100110001100110011001101100010110100110100001101000011001100111000001011010011100100110100001100000011011100101101001101010110011001100010001101100011000000110101011001000011010100110101011001100110001001100101011111010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```
- 去掉后面的0：
```
1011000010110010100001101010100010001100111101100111000011000100110001101100100011001000011001000110000001100000010110101100110011000110011001100110110001011010011010000110100001100110011100000101101001110010011010000110000001101110010110100110101011001100110001000110110001100000011010101100100001101010011010101100110011000100110010101111101
```
- 添上0b，表明这是二进制数后再long_to_bytes得到flag







```python
from Crypto.Util.number import *

b = "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567891134567799112455688902334677801133557889113356678911245577991223456790012455788902234677801124557799122355788001345578890123566789113445778012235578800123467889122356678911344567991223557880012455788912235667900124556899023355788001234578890123566780013445679902334577801134456899022346778902344578801233467789112355779912234577990233556780113"


def custom_add_decrypt(input_str):
    input_list = list(input_str)
    length = len(input_list)

    for i in range(length):
        input_list[i] = str((int(input_list[i]) - i - 1) % 10)

    result = "".join(input_list)
    return result


a = custom_add_decrypt(b)
a = "0b" + a
print(a)


def swap_bits(input_str):
    input_list = list(input_str[2:])
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp

    return "".join(input_list)


res = swap_bits(a)

print(res)
# 10110000101100101000011010101000100011001111011001110000110001001100011011001000110010000110010001100000011000000101101011001100110001100110011001101100010110100110100001101000011001100111000001011010011100100110100001100000011011100101101001101010110011001100010001101100011000000110101011001000011010100110101011001100110001001100101011111010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
leak = 0b1011000010110010100001101010100010001100111101100111000011000100110001101100100011001000011001000110000001100000010110101100110011000110011001100110110001011010011010000110100001100110011100000101101001110010011010000110000001101110010110100110101011001100110001000110110001100000011010101100100001101010011010101100110011000100110010101111101
print(long_to_bytes(int(leak)))
# b'XYCTF{8bcdd200-fc36-4438-9407-5fb605d55fbe}'


```

# 2.babyRSAMAX
```python
from Crypto.Util.number import *
from gmpy2 import *
from random import choice

flag = b"XYCTF{******}"
e = "?"


def getBabyPrime(nbits):
    while True:
        p = 1
        while p.bit_length() <= nbits:
            p *= choice(sieve_base)

        if isPrime(p + 1):
            return p + 1


p = getBabyPrime(512)
q = getBabyPrime(512)
n = p * q
gift1 = (pow(p, e, n) - pow(q, e, n)) % n
gift2 = pow(p + q, e, n)

t = 65537
x = bytes_to_long(e)
y = pow(x, t, n)

m = bytes_to_long(flag)
c = powmod(m, e, n)

print(f"n = {n}")
print(f"gift1 = {gift1}")
print(f"gift2 = {gift2}")
print(f"c = {c}")
print(f"y = {y}")

"""
n = 39332423872740210783246069030855946244104982381157166843977599780233911183158560901377359925435092326653303964261550158658551518626014048783435245471536959844874036516931542444719549997971482644905523459407775392702211086149279473784796202020281909706723380472571862792003687423791576530085747716706475220532321
gift1 = 4549402444746338327349007235818187793950285105091726167573552412678416759694660166956782755631447271662108564084382098562999950228708300902201571583419116299932264478381197034402338481872937576172197202519770782458343606060544694608852844228400457232100904217062914047342663534138668490328400022651816597367310
gift2 = 111061215998959709920736448050860427855012026815376672067601244053580566359594802604251992986382187891022583247997994146019970445247509119719411310760491983876636264003942870756402328634092146799825005835867245563420135253048223898334460067523975023732153230791136870324302259127159852763634051238811969161011462
c = 16938927825234407267026017561045490265698491840814929432152839745035946118743714566623315033802681009017695526374397370343984360997903165842591414203197184946588470355728984912522040744691974819630118163976259246941579063687857994193309554129816268931672391946592680578681270693589911021465752454315629283033043
y = 1813650001270967709841306491297716908969425248888510985109381881270362755031385564927869313112540534780853966341044526856705589020295048473305762088786992446350060024881117741041260391405962817182674421715239197211274668450947666394594121764333794138308442124114744892164155894256326961605137479286082964520217

"""

```

- 先求p,q
![alt text](d51cd0f42d3ec8030f73c74997233a1.jpg)
- 求得p，q之后可以求出x
- 直接把x当做e求解，发现怎么都不对
- 用x测试这两个发现均错误：
```python
gift1 = (pow(p, e, n) - pow(q, e, n)) % n
gift2 = pow(p + q, e, n)

```
- 那么说明直接把x当做e是错的，注意到x = bytes_to_long(e)，于是尝试print(long_to_bytes(x))
- 果然得到信息： b'XYCTF{e==4096}'
- 注意这不是flag，还没结束，调皮
- e=4096，再次计算d，发现求不出d，于是看一下公因子print(gcd(e, phi ))，公因子是4，那么把e除以4呢？发现gcd(e, phi )还是等于4，那么计算gcd(e, phi // 4)，终于互素了
- 计算d = gmpy2.invert(e, phi // 4)，那么问题来了，m该如何计算呢？m = pow(c, d, n)么？试了一下不行，模p也不行，最后模q得到flag
- EXP:
```python
from Crypto.Util.number import *
from gmpy2 import *

n = 39332423872740210783246069030855946244104982381157166843977599780233911183158560901377359925435092326653303964261550158658551518626014048783435245471536959844874036516931542444719549997971482644905523459407775392702211086149279473784796202020281909706723380472571862792003687423791576530085747716706475220532321
gift1 = 4549402444746338327349007235818187793950285105091726167573552412678416759694660166956782755631447271662108564084382098562999950228708300902201571583419116299932264478381197034402338481872937576172197202519770782458343606060544694608852844228400457232100904217062914047342663534138668490328400022651816597367310
gift2 = 111061215998959709920736448050860427855012026815376672067601244053580566359594802604251992986382187891022583247997994146019970445247509119719411310760491983876636264003942870756402328634092146799825005835867245563420135253048223898334460067523975023732153230791136870324302259127159852763634051238811969161011462
c = 16938927825234407267026017561045490265698491840814929432152839745035946118743714566623315033802681009017695526374397370343984360997903165842591414203197184946588470355728984912522040744691974819630118163976259246941579063687857994193309554129816268931672391946592680578681270693589911021465752454315629283033043
y = 1813650001270967709841306491297716908969425248888510985109381881270362755031385564927869313112540534780853966341044526856705589020295048473305762088786992446350060024881117741041260391405962817182674421715239197211274668450947666394594121764333794138308442124114744892164155894256326961605137479286082964520217
p = gcd(gift1 + gift2, n)
q = n // p
phi = (p - 1) * (q - 1)
t = 65537

d_t = gmpy2.invert(t, q - 1)
x = pow(y, d_t, q)
print(long_to_bytes(x))
e = 4096

print(gcd(e, phi // 4))
d = gmpy2.invert(e, phi // 4)
m = pow(c, d, q)
print(long_to_bytes(m))
# b'XYCTF{Rabin_is_so_biggggg!}'
```
- 提示rabin，也是，公因子是4嘛，那么如何使用rabin解密呢？

# 3.factor1
- 题目
```python
import gmpy2
import hashlib
from Crypto.Util.number import *

p = getPrime(512)
q = getPrime(512)
d = getPrime(512)
e = gmpy2.invert(d, (p**3 - 1) * (q**3 - 1))
flag = "XYCTF{" + hashlib.md5(str(p + q).encode()).hexdigest() + "}"
print(e)
print(p * q)
# 172005065945326769176157335849432320425605083524943730546805772515111751580759726759492349719668775270727323745284785341119685198468883978645793770975366048506237371435027612758232099414404389043740306443065413069994232238075194102578269859784981454218948784071599231415554297361219709787507633404217550013282713899284609273532223781487419770338416653260109238572639243087280632577902857385265070736208291583497988891353312351322545840742380550393294960815728021248513046077985900158814037534487146730483099151396746751774427787635287611736111679074330407715700153025952858666841328055071403960165321273972935204988906850585454805923440635864200149694398767776539993952528995717480620593326867245714074205285828967234591508039849777840636255379730281105670496110061909219669860172557450779495125345533232776767292561378244884362014224844319802810586344516400297830227894063759083198761120293919537342405893653545157892446163
# 99075185389443078008327214328328747792385153883836599753096971412377366865826254033534293886034828804219037466246175526347014045811852531994537520303063113985486063022444972761276531422538694915030159420989401280012025249129111871649831185047820236417385693285461420040134313833571949090757635806658958193793

```
- e很大，采用维纳攻击
- 此题phi=(p^3-1)(q^3-1),所以n需要使用n^3
- 解得的p*q=n^3,所以p和q均需要开三次方
- EXP:
```python
import gmpy2
import libnum
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相除将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res


def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回


# 求解每个渐进分数
def sub_fraction(x, y):
    res = transform(x, y)
    res = list(
        map(continued_fraction, (res[0:i] for i in range(1, len(res))))
    )  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过韦达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for d, k in sub_fraction(
        e, n
    ):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (
            e * d - 1
        ) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
        px, qy = get_pq(1, n - phi + 1, n)
        if px * qy == n:
            p, q = abs(int(px)), abs(
                int(qy)
            )  # 可能会得到两个负数，负负得正未尝不会出现
            d = gmpy2.invert(
                e, (p - 1) * (q - 1)
            )  # 求ed=1 (mod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d
            p = gmpy2.iroot(p, 3)[0]
            q = gmpy2.iroot(q, 3)[0]
            return d, p, q
    print("该方法不适用")


e = 172005065945326769176157335849432320425605083524943730546805772515111751580759726759492349719668775270727323745284785341119685198468883978645793770975366048506237371435027612758232099414404389043740306443065413069994232238075194102578269859784981454218948784071599231415554297361219709787507633404217550013282713899284609273532223781487419770338416653260109238572639243087280632577902857385265070736208291583497988891353312351322545840742380550393294960815728021248513046077985900158814037534487146730483099151396746751774427787635287611736111679074330407715700153025952858666841328055071403960165321273972935204988906850585454805923440635864200149694398767776539993952528995717480620593326867245714074205285828967234591508039849777840636255379730281105670496110061909219669860172557450779495125345533232776767292561378244884362014224844319802810586344516400297830227894063759083198761120293919537342405893653545157892446163
n = 99075185389443078008327214328328747792385153883836599753096971412377366865826254033534293886034828804219037466246175526347014045811852531994537520303063113985486063022444972761276531422538694915030159420989401280012025249129111871649831185047820236417385693285461420040134313833571949090757635806658958193793
d, p, q = wienerAttack(e, n * n * n)
assert p * q == n
import hashlib

flag = "XYCTF{" + hashlib.md5(str(p + q).encode()).hexdigest() + "}"
print(flag)
# XYCTF{a83211a70e18145a59671c08ddc67ba4}
```