# 1.Sign1n[签到]
- 题目：
```python
from Crypto.Util.number import *
from tqdm import *
import gmpy2
flag=b'XYCTF{uuid}'
flag=bytes_to_long(flag)
leak=bin(int(flag))
while 1:
    leak += "0"
    if len(leak) == 514:
        break

def swap_bits(input_str):
    input_list = list(input_str[2:])
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp

    return ''.join(input_list)

input_str = leak
result = swap_bits(input_str)
a=result

def custom_add(input_str):
    input_list = list(input_str)
    length = len(input_list)
    
    for i in range(length):
        input_list[i] = str((int(input_list[i]) + i + 1) % 10)

    result = ''.join(input_list)
    return result


input_str = a
result = custom_add(input_str)
b=result
print(b)
#12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567891134567799112455688902334677801133557889113356678911245577991223456790012455788902234677801124557799122355788001345578890123566789113445778012235578800123467889122356678911344567991223557880012455788912235667900124556899023355788001234578890123566780013445679902334577801134456899022346778902344578801233467789112355779912234577990233556780113
```
- 分析题目flag主要是被做了两次变换
- 第一次swap_bits()，交换了前后元素的位置，解密时可以直接用这个函数
- 第二次custom_add()，做了一些移位替换，解密只需要将str((int(input_list[i]) + i + 1) % 10)里面的加号换成减号
- 注意细节leak是二进制字符串，在swap_bits()交换元素是现去掉了"0b"，所以解密时需要添上"0b"再使用swap_bits()
- 解密过程：先将得到的数字以字符串形式表示，传入custom_add_decrypt()中进行移位变换，得到a，给a添上"0b"后使用swap_bits()交换元素位置，得到res:
```
10110000101100101000011010101000100011001111011001110000110001001100011011001000110010000110010001100000011000000101101011001100110001100110011001101100010110100110100001101000011001100111000001011010011100100110100001100000011011100101101001101010110011001100010001101100011000000110101011001000011010100110101011001100110001001100101011111010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```
- 去掉后面的0：
```
1011000010110010100001101010100010001100111101100111000011000100110001101100100011001000011001000110000001100000010110101100110011000110011001100110110001011010011010000110100001100110011100000101101001110010011010000110000001101110010110100110101011001100110001000110110001100000011010101100100001101010011010101100110011000100110010101111101
```
- 添上0b，表明这是二进制数后再long_to_bytes得到flag







```python
from Crypto.Util.number import *

b = "12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567891134567799112455688902334677801133557889113356678911245577991223456790012455788902234677801124557799122355788001345578890123566789113445778012235578800123467889122356678911344567991223557880012455788912235667900124556899023355788001234578890123566780013445679902334577801134456899022346778902344578801233467789112355779912234577990233556780113"


def custom_add_decrypt(input_str):
    input_list = list(input_str)
    length = len(input_list)

    for i in range(length):
        input_list[i] = str((int(input_list[i]) - i - 1) % 10)

    result = "".join(input_list)
    return result


a = custom_add_decrypt(b)
a = "0b" + a
print(a)


def swap_bits(input_str):
    input_list = list(input_str[2:])
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp

    return "".join(input_list)


res = swap_bits(a)

print(res)
# 10110000101100101000011010101000100011001111011001110000110001001100011011001000110010000110010001100000011000000101101011001100110001100110011001101100010110100110100001101000011001100111000001011010011100100110100001100000011011100101101001101010110011001100010001101100011000000110101011001000011010100110101011001100110001001100101011111010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
leak = 0b1011000010110010100001101010100010001100111101100111000011000100110001101100100011001000011001000110000001100000010110101100110011000110011001100110110001011010011010000110100001100110011100000101101001110010011010000110000001101110010110100110101011001100110001000110110001100000011010101100100001101010011010101100110011000100110010101111101
print(long_to_bytes(int(leak)))
# b'XYCTF{8bcdd200-fc36-4438-9407-5fb605d55fbe}'


```

# 2.babyRSAMAX
```python
from Crypto.Util.number import *
from gmpy2 import *
from random import choice

flag = b"XYCTF{******}"
e = "?"


def getBabyPrime(nbits):
    while True:
        p = 1
        while p.bit_length() <= nbits:
            p *= choice(sieve_base)

        if isPrime(p + 1):
            return p + 1


p = getBabyPrime(512)
q = getBabyPrime(512)
n = p * q
gift1 = (pow(p, e, n) - pow(q, e, n)) % n
gift2 = pow(p + q, e, n)

t = 65537
x = bytes_to_long(e)
y = pow(x, t, n)

m = bytes_to_long(flag)
c = powmod(m, e, n)

print(f"n = {n}")
print(f"gift1 = {gift1}")
print(f"gift2 = {gift2}")
print(f"c = {c}")
print(f"y = {y}")

"""
n = 39332423872740210783246069030855946244104982381157166843977599780233911183158560901377359925435092326653303964261550158658551518626014048783435245471536959844874036516931542444719549997971482644905523459407775392702211086149279473784796202020281909706723380472571862792003687423791576530085747716706475220532321
gift1 = 4549402444746338327349007235818187793950285105091726167573552412678416759694660166956782755631447271662108564084382098562999950228708300902201571583419116299932264478381197034402338481872937576172197202519770782458343606060544694608852844228400457232100904217062914047342663534138668490328400022651816597367310
gift2 = 111061215998959709920736448050860427855012026815376672067601244053580566359594802604251992986382187891022583247997994146019970445247509119719411310760491983876636264003942870756402328634092146799825005835867245563420135253048223898334460067523975023732153230791136870324302259127159852763634051238811969161011462
c = 16938927825234407267026017561045490265698491840814929432152839745035946118743714566623315033802681009017695526374397370343984360997903165842591414203197184946588470355728984912522040744691974819630118163976259246941579063687857994193309554129816268931672391946592680578681270693589911021465752454315629283033043
y = 1813650001270967709841306491297716908969425248888510985109381881270362755031385564927869313112540534780853966341044526856705589020295048473305762088786992446350060024881117741041260391405962817182674421715239197211274668450947666394594121764333794138308442124114744892164155894256326961605137479286082964520217

"""

```

- 先求p,q
![alt text](d51cd0f42d3ec8030f73c74997233a1.jpg)
- 求得p，q之后可以求出x
- 直接把x当做e求解，发现怎么都不对
- 用x测试这两个发现均错误：
```python
gift1 = (pow(p, e, n) - pow(q, e, n)) % n
gift2 = pow(p + q, e, n)

```
- 那么说明直接把x当做e是错的，注意到x = bytes_to_long(e)，于是尝试print(long_to_bytes(x))
- 果然得到信息： b'XYCTF{e==4096}'
- 注意这不是flag，还没结束，调皮
- e=4096，再次计算d，发现求不出d，于是看一下公因子print(gcd(e, phi ))，公因子是4，那么把e除以4呢？发现gcd(e, phi )还是等于4，那么计算gcd(e, phi // 4)，终于互素了
- 计算d = gmpy2.invert(e, phi // 4)，那么问题来了，m该如何计算呢？m = pow(c, d, n)么？试了一下不行，模p也不行，最后模q得到flag
- EXP:
```python
from Crypto.Util.number import *
from gmpy2 import *

n = 39332423872740210783246069030855946244104982381157166843977599780233911183158560901377359925435092326653303964261550158658551518626014048783435245471536959844874036516931542444719549997971482644905523459407775392702211086149279473784796202020281909706723380472571862792003687423791576530085747716706475220532321
gift1 = 4549402444746338327349007235818187793950285105091726167573552412678416759694660166956782755631447271662108564084382098562999950228708300902201571583419116299932264478381197034402338481872937576172197202519770782458343606060544694608852844228400457232100904217062914047342663534138668490328400022651816597367310
gift2 = 111061215998959709920736448050860427855012026815376672067601244053580566359594802604251992986382187891022583247997994146019970445247509119719411310760491983876636264003942870756402328634092146799825005835867245563420135253048223898334460067523975023732153230791136870324302259127159852763634051238811969161011462
c = 16938927825234407267026017561045490265698491840814929432152839745035946118743714566623315033802681009017695526374397370343984360997903165842591414203197184946588470355728984912522040744691974819630118163976259246941579063687857994193309554129816268931672391946592680578681270693589911021465752454315629283033043
y = 1813650001270967709841306491297716908969425248888510985109381881270362755031385564927869313112540534780853966341044526856705589020295048473305762088786992446350060024881117741041260391405962817182674421715239197211274668450947666394594121764333794138308442124114744892164155894256326961605137479286082964520217
p = gcd(gift1 + gift2, n)
q = n // p
phi = (p - 1) * (q - 1)
t = 65537

d_t = gmpy2.invert(t, q - 1)
x = pow(y, d_t, q)
print(long_to_bytes(x))
e = 4096

print(gcd(e, phi // 4))
d = gmpy2.invert(e, phi // 4)
m = pow(c, d, q)
print(long_to_bytes(m))
# b'XYCTF{Rabin_is_so_biggggg!}'
```
- 提示rabin，也是，公因子是4嘛，那么如何使用rabin解密呢？